/* Icon Graph

Icon Graph Visualization Extension Object for QlikView based on Vis.js version 4.x (JavaScript): http://www.visjs.org/

Created by Ralf Becher - ralf.becher@web.de - (c) 2015, irregular.bi, Leipzig, Germany

This extension uses images from flaticon.com:

License and attribution:
Font generated by <a href="http://www.flaticon.com">flaticon.com</a>
 under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY</a>. The authors are: <a href="http://fontawesome.io">Dave Gandy</a>.

Tested with QlikView version 11.2

irregular.bi takes no responsbility for any code.
Use at your own risk. 
*/

// This checks if the console is present, and if not it 
// sets it to an object with a blank function called log to
// prevent any error. Remove logging for production.
if(!window.console){ window.console = {log: function(){} }; } 

(function ($) {
	//own context, avoiding conflicts with other libraries, $=jQuery
	var _extension = 'IconGraph2';
    var _path = 'Extensions/' + _extension + '/';
	var _pathLong = Qva.Remote + (Qva.Remote.indexOf('?') >= 0 ? '&' : '?') + 'public=only&name=' + _path;
	// detect WebView mode (QlikView Desktop)
	var _webview = window.location.host === 'qlikview';
	var _files = [];
	// create array with all need libraries
    _files.push(_path + 'js/vis.js');

	// load all libraries as array, don't use nested Qva.LoadScript() calls
	Qv.LoadExtensionScripts(_files, 
		function () {
			// load css file
			Qva.LoadCSS((_webview ? _path : _pathLong) + "css/style.css");
			Qva.LoadCSS((_webview ? _path : _pathLong) + "css/vis.css");
			
			var imgUrl = (_webview ? _path : _pathLong) + "img/";
			
			Qv.AddExtension(_extension,
				function () {
				var _this = this;
				var _id = _this.Layout.ObjectId.replace("\\", "_");
				var _buttonId = 'force-layout_' + _id,
					_menuId = 'canvas-menu_' + _id,
					_maxDisplayEdges = 500;
 
				var nodeTypes = this.Layout.Text0.text.toString().split(","),
					colorPalette = this.Layout.Text1.text.toString().split(","),
					iconPalette = this.Layout.Text2.text.toString().split(","),
					graphDirected = ((this.Layout.Text3.text.toString() * 1) >0),
					edgeStyle = this.Layout.Text4.text.toString(),
					edgeLabelColor = this.Layout.Text5.text.toString(),
					edgeLabelFontSize = this.Layout.Text6.text.toString() * 1;
					
			console.log(edgeStyle);
			
				// Create new div element inside existing (QvContent)
				var wrapper = $('<div />')
							.attr({ id: _id })
							.appendTo($(_this.Element).empty());

				// How many rows do we have? Log it to console (see Firebug extension)
				console.log('Rows: '+this.Data.Rows.length);

                var nodes = Array(),
					edges = Array(),
					nodesObj = Array(),
					edgesObj = Array(),
					nodeTypesLkp = Array(),
					iconGroup = {},
					node1Name = "",
					node2Name = "",
					node1Id = -1,
					node2Id = -1,
					nodeType1 = "",
					nodeType2 = "",
					typeIdx1 = -1,
					typeIdx2 = -1,
					delimPos1 = -1,
					delimPos2 = -1;

                var parentLabel = _this.Data.HeaderRows[0][3].text || false,
                    childLabel = _this.Data.HeaderRows[0][4].text || false,
                    edgeLabel = _this.Data.HeaderRows[0][5].text || false,
                    parentSize = _this.Data.HeaderRows[0][6].text || false,
                    childSize = _this.Data.HeaderRows[0][7].text || false,
                    edgeColor = _this.Data.HeaderRows[0][8].text || false,
                    parentTooltip = _this.Data.HeaderRows[0][9].text || false,
                    childTooltip = _this.Data.HeaderRows[0][10].text || false,
                    edgeTooltip = _this.Data.HeaderRows[0][11].text || false
                ;
				var minScale = 999999, maxScale = 0;
				
				//console.log(_this.Data.Rows);
                for (var i = 0, k = Math.min(_this.Data.Rows.length,_maxDisplayEdges); i < k; i++) {
                    var row = _this.Data.Rows[i];
					//console.log(row);
					node1Name = row[0].text;
					node2Name = row[1].text;
										
					node1Id = pushNode(node1Name,
						parentLabel ? row[3].text.replace(":", ":\n") : "", 
						parentSize ? (row[6].data * 1) : 16,
						parentTooltip ? row[9].text : "",
						nodes, nodesObj, nodeTypes, nodeTypesLkp, iconGroup, 
						imgUrl, iconPalette, colorPalette)

					node2Id = pushNode(node2Name,
						childLabel ? row[4].text.replace(":", ":\n") : "", 
						childSize ? (row[7].data * 1) : 16,
						childTooltip ? row[10].text : "",
						nodes, nodesObj, nodeTypes, nodeTypesLkp, iconGroup, 
						imgUrl, iconPalette, colorPalette)

					if (node1Id > 0 && node2Id > 0) {
						pushEdge(node1Id, node2Id, edges, edgesObj,
							edgeLabel ? row[5].text : "", 
							edgeLabelFontSize, edgeLabelColor, 
							edgeColor ? row[8].text : edgeLabelColor, edgeStyle, graphDirected);
                    }
					
					minScale = Math.min(Math.min(minScale, parentSize ? (row[6].data * 1) : 16), childSize ? (row[7].data * 1) : 16);
					maxScale = Math.max(Math.max(maxScale, parentSize ? (row[6].data * 1) : 16), childSize ? (row[7].data * 1) : 16);
				};
				
				// create a network
				var data = {
						nodes: nodesObj,
						edges: edgesObj
					};
console.log(data);			
console.log({minScale:minScale,maxScale:maxScale})
				var options = {
						height: _this.GetHeight()+"px",
						interaction: {
							navigationButtons: true,
							keyboard: true
						},
						groups: iconGroup,
						physics: {
							stabilization: {
							  enabled: true,
							  iterations: 1000
							}
						},
						nodes: {
							shape: 'image',
							scaling: {
								customScalingFunction: function (min,max,total,value) {
									var ret = 0, scale = 0;
									if (max === min) {
										ret = 0.5;
									} else {
										scale = 1 / (max - min);
										ret = Math.max(0,(value - min)*scale);
									}
									console.log({min:min,max:max,total:total,value:value,scale:scale,ret:ret});
									return ret;
								},
							min: minScale, 
							max: maxScale
							}
						}
					};
				var container = document.getElementById(_id);
				var network = new vis.Network(container, data, options);

				// patch css path for server
				if (!_webview) {
					$.each($(".vis-button"), function( index, element ) {
						element.css("background-image", _pathLong + "css/" + element.css("background-image"));
					});
				}
				
				var menu = $('<menu />').attr({ id: _menuId}).appendTo(wrapper);
				menu.append('<button class="btn" id="'+_buttonId+'" style="position:absolute;top:1px;left:1px;font: bold 12px Arial;outline:none;color:#325078">force</button>');
				
				$( document ).ready(function() {
						setTimeout(function(){
							network.stopSimulation();
							console.log("stopSimulation");
							// patch css path for server
							if (!_webview) {
								$.each($(".vis-button"), function( index, element ) {
									var url = $(element).css("background-image");
									var patchUrl = 'url("' + _pathLong + "css/" + url.substr(url.indexOf("img/network/"));
									//console.log(patchUrl);
									$(element).css("background-image", patchUrl);
								});
							}
							}, 2000);
				});

				// bind force button action
				var isRunning = false;
				document.getElementById(_buttonId).addEventListener('click',function(){
					if(isRunning){
					  isRunning = false;
					  network.stopSimulation();
					  document.getElementById(_buttonId).childNodes[0].nodeValue = 'force';
					}else{
					  isRunning = true;
					  network.startSimulation()
					  document.getElementById(_buttonId).childNodes[0].nodeValue = 'stop';
					}
				},true);

				// add event listeners
				// network.on('click', function(e) {
					// if (e.ctrlKey)
						// return false;				
				// });
				
				// network.on('select', function(params) {				
					// console.log(params);
					// //document.getElementById('selection').innerHTML = 'Selection: ' + params.nodes;
					// if (params.nodes != "") {
						// //if ()
						// console.log('Selection: ' + params.nodes);
					// }
				// });
				
            });
       });

})(jQuery);

function pushNode(_name, _label, _nodeSize, _tooltip, _nodes, _nodesObj, _nodeTypes, _nodeTypesLkp, _iconGroup, _imgUrl, _iconPalette, _colorPalette) {
	var _id = $.inArray(_name, _nodes),
		_pos = _name.indexOf(":"),
		_typeLabel = "",
		_typeIdx = -1;
	if (_pos > 0) _typeLabel = _name.substr(0, _pos);
	if (_id == -1) {
		_typeIdx = $.inArray(_typeLabel, _nodeTypesLkp);
		if (_typeIdx == -1 && _typeLabel != "") {
			// add to nodes types index
			_nodeTypesLkp.push(_typeLabel);
			_typeIdx = $.inArray(_typeLabel, _nodeTypes);
			if (_typeIdx != -1) {
				// create icon group
				_iconGroup[_typeLabel] = {
						shape: 'image',
						image: _imgUrl + _iconPalette[_typeIdx % _iconPalette.length],
						brokenImage: _imgUrl + "circle33.png",
						font: {
							color: _colorPalette[_typeIdx % _colorPalette.length]
						}
					};
			}
		}
		// add to nodes index
		_nodes.push(_name);
		_id = _nodes.length;
		var _par = _label.lastIndexOf("(");
		if (_par > 0)
			_label =  _label.substring(0,_par) + '\n' + _label.substring(_par);
		// create nodes object and add it
		var n = {
			id: _id,
			label: _label,
			value: _nodeSize,
			title: _tooltip,
			group: _typeLabel
		}
//console.log(n);
		_nodesObj.push(n);
	} else {
		_id ++;
	}
	return _id
}

function pushEdge(_IdFrom, _IdTo, _edges, _edgesObj, _edgeLabel, _edgeLabelFontSize, _edgeLabelColor, _edgeColor, _edgeStyle, _graphDirected) {
//console.log(_IdFrom + "_" + _IdTo);
	if (!_graphDirected) {
		// prevent edge with opposite direction
		if ($.inArray(_IdTo + "_" + _IdFrom, _edges) == -1) {
			if ($.inArray(_IdFrom + "_" + _IdTo, _edges) == -1) {
				_edges.push(_IdFrom + "_" + _IdTo);							
				_edgesObj.push({
					from: _IdFrom,
					to: _IdTo,
					style: _edgeStyle,
					label: _edgeLabel,
					title: _edgeLabel,
					fontSize: _edgeLabelFontSize,
					fontColor: _edgeLabelColor,
					color: _edgeColor
				});
			}
		}
	} else {
		if ($.inArray(_IdFrom + "_" + _IdTo, _edges) == -1) {
			_edges.push(_IdFrom + "_" + _IdTo);							
			_edgesObj.push({
				from: _IdFrom,
				to: _IdTo,
				style: _edgeStyle,
				label: _edgeLabel,
				title: _edgeLabel,
				fontSize: _edgeLabelFontSize,
				fontColor: _edgeLabelColor == "" ? _edgeColor : _edgeLabelColor,
				color: _edgeColor
			});
		}                       
	} 
}